---
title: Выбор алгоритма сортировки с ограничениями
weight: 3
authors:
- [Дмитрий Попович]
created: 2025
---

При решении алгоритмических задач часто возникают ситуации, когда недостаточно просто отсортировать данные — необходимо учитывать дополнительные ограничения на время выполнения, память или другие ресурсы. В таких случаях ключевым становится умение выбрать оптимальный алгоритм сортировки, учитывающий все заданные ограничения.

## Компромиссы алгоритмов сортировки

Основные алгоритмы сортировки можно классифицировать по их временной и пространственной сложности:

| Алгоритм | Время (сравнения) | Память | Особенности |
|----------|-------------------|---------|-------------|
| **QuickSort** | $O(n \log n)$ | $O(\log n)$ | В среднем быстрый, но $O(n^2)$ в худшем случае |
| **MergeSort** | $O(n \log n)$ | $O(n)$ | Стабильный, предсказуемое время |
| **HeapSort** | $O(n \log n)$ | $O(1)$ | In-place, гарантированная сложность |
| **Counting Sort** | $O(n + k)$ | $O(k)$ | Линейное время при малом $k$ |
| **Radix Sort** | $O(d \cdot (n + b))$ | $O(n + b)$ | Линейное время для целых чисел |
| **Insertion Sort** | $O(n^2)$ | $O(1)$ | Эффективен для малых $n$ |

где:
- $n$ — количество элементов
- $k$ — диапазон значений (max - min + 1)
- $d$ — количество цифр
- $b$ — основание системы счисления

## Критерии выбора алгоритма

### Когда использовать Counting Sort
**Условия:**
- Диапазон значений $k$ мал: $k \leq \text{maxMemory} / 2$
- Ограничения на сравнения строгие
- Доступно достаточно памяти: $n + k \leq \text{maxMemory}$

**Преимущество:** Минимальное количество сравнений — практически нулевое.

### Когда использовать Radix Sort  
**Условия:**
- Данные — целые числа или строки
- Умеренные ограничения на память: $2n \leq \text{maxMemory}$
- Желательно предсказуемое время выполнения

**Особенность:** Количество проходов зависит от количества цифр.

### Когда использовать HeapSort
**Условия:**
- Строгие ограничения на память: $\text{maxMemory} \leq 50$
- Большие объемы данных
- Гарантированное время $O(n \log n)$ необходимо

**Преимущество:** Работает на месте, не требует дополнительной памяти.

### Когда использовать Insertion Sort
**Условия:**
- Очень строгие ограничения на память: $\text{maxMemory} \leq 10$
- Малое количество элементов: $n \leq 1000$
- Мягкие ограничения на сравнения

**Применение:** Крайние случаи с минимальной доступной памятью.

## Анализ ограничений

Пусть заданы три параметра:
- $\text{maxValue}$ — максимальное значение элемента
- $\text{maxCount}$ — максимальное количество сравнений  
- $\text{maxMemory}$ — максимальная дополнительная память

### Алгоритм выбора

1. **Проверить Counting Sort:**
   $$
   k = \text{maxValue} - \min(\text{nums}) + 1
   $$
   Если $k \leq \text{maxMemory}/2$ и $k \leq 200000$ → использовать Counting Sort

2. **Проверить Radix Sort:**
   Если $2n \leq \text{maxMemory}$ → использовать Radix Sort

3. **Проверить Merge Sort:**
   Если $\text{maxMemory} \geq n$ → использовать Merge Sort

4. **Выбрать между HeapSort и Insertion Sort:**
   - Если $n \leq 1000$ или $\text{maxCount} \geq n^2$ → Insertion Sort
   - Иначе → HeapSort

## Практическое правило

Для безопасной сортировки при неизвестных данных рекомендуется:

- При наличии памяти $O(n)$ — **MergeSort** (стабильный, предсказуемый)
- При ограниченной памяти — **HeapSort** (гарантированная сложность)  
- При известном малом диапазоне значений — **Counting Sort** (линейное время)
- При работе с целыми числами — **Radix Sort** (линейное время)

## Бонус: "Адаптивная сортировка"

На практике можно реализовать гибридный подход, который анализирует входные данные и ограничения в runtime, выбирая оптимальный алгоритм автоматически. Такой подход особенно полезен в системах, где характеристики входных данных могут значительно варьироваться.
